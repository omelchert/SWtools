<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>SWtools_base API documentation</title>
<meta name="description" content="SWtools …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SWtools_base</code></h1>
</header>
<section id="section-intro">
<p>SWtools.</p>
<p>This module implements data structures and algorithms that allow a user to
conveniently calculate solitary-wave solutions for a generalized
nonlinear-Schrödinger type equation.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SWtools_base.helper_show_d1"><code class="name flex">
<span>def <span class="ident">helper_show_d1</span></span>(<span>xi, U, it, acc, f_name='none')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def helper_show_d1(xi, U, it, acc, f_name=&#39;none&#39;):
    &#34;&#34;&#34;Helper function for making simple plots in dimension d=1.

    Uses Pythons matplotlibe to prepare a two-panel figure that might be
    captioned as follows:

    Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
    panel: Solution U.  Shown are the real part (Re[U]), imaginary part
    (Im[U]), and modulus (|U|) of the solution.  Right panel: Variation of the
    accuracy upon iteration.

    Parameters
    ----------
    xi : array_like
        Discretized transverse coordinate xi.
    U : array_like
        Solution of the nonlinear eigenvalue problem.
    it : array_like
        List of iteration steps at which results where stored.
    acc : array_like
        List of accuracy values corresponding to the iteration steps in `it`.
    f_name : str, optional
        Figure name. If no name is set, the figure is displayed directly.
    &#34;&#34;&#34;
    # -- FIGURE LAYOUT 
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6,3))

    # -- LEFT SUBPLOT
    ax1.plot(xi, np.real(U), color=&#39;C0&#39;, dashes=[], label=r&#34;${\rm{Re}}[U]$&#34;)
    ax1.plot(xi, np.imag(U), color=&#39;C0&#39;, dashes=[2,1], label=r&#34;${\rm{Im}}[U]$&#34;)
    ax1.plot(xi, np.abs(U), color=&#39;gray&#39;, dashes=[1,1], label=r&#34;$|U|$&#34;)
    ax1.set_xlabel(r&#34;Coordinate $\xi$&#34;)
    ax1.set_ylabel(r&#34;Solution $U$&#34;)
    legend = ax1.legend()

    # -- RIGHT SUBPLOT
    ax2.plot(it, np.log10(acc), color=&#39;C0&#39;)
    ax2.set_xlabel(r&#34;Iteration $n$&#34;)
    ax2.set_ylabel(r&#34;log-accuracy $\log(\epsilon_n)$&#34;)

    # -- SHOW/SAVE FIGURE
    plt.tight_layout()

    if f_name==&#39;none&#39;:
        plt.show()
    else:
        plt.savefig(f_name)</code></pre>
</details>
<div class="desc"><p>Helper function for making simple plots in dimension d=1.</p>
<p>Uses Pythons matplotlibe to prepare a two-panel figure that might be
captioned as follows:</p>
<p>Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
panel: Solution U.
Shown are the real part (Re[U]), imaginary part
(Im[U]), and modulus (|U|) of the solution.
Right panel: Variation of the
accuracy upon iteration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Discretized transverse coordinate xi.</dd>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Solution of the nonlinear eigenvalue problem.</dd>
<dt><strong><code>it</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of iteration steps at which results where stored.</dd>
<dt><strong><code>acc</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of accuracy values corresponding to the iteration steps in <code>it</code>.</dd>
<dt><strong><code>f_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Figure name. If no name is set, the figure is displayed directly.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SWtools_base.IterBase"><code class="flex name class">
<span>class <span class="ident">IterBase</span></span>
<span>(</span><span>xi, tol=1e-12, maxiter=10000, nskip=1, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IterBase(object):
    &#34;&#34;&#34;Base class for the implemented iteration methods.

    Attributes
    ----------
    xi : array_like
        Discretized coordinate xi.
    tol : float
        Convergence is assumed if relative error falls below this value
        (defaulf: tol=1e-12).
    maxiter : int
        Maximum number of iterations to perform (default: maxiter=10000).
    nskip : float
        Number of iterations to skip in between storing intermediate results
        (default: 1).
    verbose : bool
        Set to True to print details during iteration (default: False).
    iter_list : array_like
        Sequence of iteration steps at which intermediate results where stored
        (separated by nskip steps).
    U_list : array_like
        List of intermediate solutions U.
    acc_list : array_like
        List of intermediate accuracies (see class method _accuracy() below).
    N_list : array_like
        List of intermediate values of the integral N[U].
    H_list : array_like
        List of intermediate values of the integral H[U].
    K_list : array_like
        List of intermediate values of the eigenvalue estimate K=H[U]/N[U].

    &#34;&#34;&#34;
    def __init__(self, xi, tol=1e-12, maxiter=10000, nskip=1, verbose=False):
        &#34;&#34;&#34;Initialization of the iteration base class.

        Parameters
        ----------
        xi : array_like
            Discretized coordinate xi.
        tol : float, optional
            Iteration is stopped if the accuracy falls below this tolerance
            threshold (default: 1e-12).
        maxiter : int, optional
            Maximum number of allowed iterations (default: 10000).
        nskip : 1, optional
            Number of iterations to skip in between storing intermediate results (default: 1)
        verbose : bool
            Set to True to print details during iteration (default: False)
        &#34;&#34;&#34;
        self.xi = xi
        self.tol = tol
        self.maxiter = maxiter
        self.nskip = nskip
        self.verbose = verbose
        self.iter_list = []
        self.U_list = []
        self.acc_list = []
        self.N_list = []
        self.H_list = []
        self.K_list = []

    @property
    def U(self):
        &#39;&#39;&#39;float: Final solution U.&#39;&#39;&#39;
        return self.U_list[-1]

    @property
    def kap(self):
        &#39;&#39;&#39;float: Value of the eigenvalue.&#39;&#39;&#39;
        return self.K_list[-1]

    @property
    def N(self):
        &#39;&#39;&#39;float: Value of functional 1.&#39;&#39;&#39;
        return self.N_list[-1]

    @property
    def H(self):
        &#39;&#39;&#39;float: Value of functional 2.&#39;&#39;&#39;
        return self.H_list[-1]

    @property
    def acc(self):
        &#39;&#39;&#39;float: Terminal accuracy.&#39;&#39;&#39;
        return self.acc_list[-1]

    @property
    def num_iter(self):
        &#39;&#39;&#39;int: Number of iterations performed.&#39;&#39;&#39;
        return self.iter_list[-1]

    def _clean_up(self):
        &#39;&#39;&#39;Cleanup of attributes at beginning of each solution run.&#39;&#39;&#39;
        self.U_list = []
        self.acc_list = []
        self.iter_list = []
        self.N_list = []
        self.H_list = []
        self.K_list = []

    def _update_results(self, it, U, N, H, kap, err):
        &#39;&#39;&#39;Update attributes using the supplied intermediate results.&#39;&#39;&#39;
        self.iter_list.append(it)
        self.N_list.append(N)
        self.H_list.append(H)
        self.K_list.append(kap)
        self.U_list.append(np.copy(U))
        self.acc_list.append(err)
        if self.verbose:
            print(self)

    def solve(self, U, dum, **kwargs):
        &#39;&#39;&#39;Performs iteration procedure.

        Parameters
        ----------
        U : array_like
            Initial condition.
        dum : float
            Eigenvalue (in case of SRM) or value of the normalization
            constraint (in case of NSOM).
        ortho_set : array_like, keyword argument
            List of previously found orthogonal solutions.
        acc_fun : function, keyword argument
            Custom accuracy function with call signature `acc_fun(xi, Up, Uc)`,
            where the arguments are the coordinate xi (`xi`), the solution at the
            previous iteration step (`Up`), and the solution at the current
            iteration step (`Uc`).

        Returns
        -------
        U : array_like
            Final solutions.
        acc : float
            Terminal accuracy.
        succ : bool
            Boolean flag indicating if teh iteration procedure exited
            successfully.
        msg : str
            Cause of the termination.
        &#39;&#39;&#39;
        # -- USEFUL FUNCTIONS AND ABBREVIATIONS
        # ... STRIP SELF KEYWORD
        xi, tol, maxiter, nskip = self.xi, self.tol, self.maxiter, self.nskip
        # ... LOCAL FUNCTIONS
        acc_fun_def = lambda xi, U, Un: np.sqrt(np.sum(np.abs(Un - U)**2)/np.sum(np.abs(U)**2))
        # -- LOGIC TO MAP OUT KEYWORD ARGUMENTS
        ortho_set = kwargs.get(&#34;ortho_set&#34;, [])
        acc_fun = kwargs.get(&#34;acc_fun&#34;, acc_fun_def)
        # -- CLEAN UP
        self._clean_up()

        # -- PREPARE/EVALUATE TRIAL SOLUTION
        N = self.functional_N(U)
        H = self.functional_H(U)
        # -- INITIALIZE ITERATION SCHEME
        it = 1
        acc = np.inf
        # -- KEEP INITIAL RESULTS
        self._update_results(0, U, N, H, H/N, acc)
        # -- ITERATION PROCEDURE
        while acc &gt; tol and it &lt; maxiter:
            # ... ORTHOGONALIZE WRT NOT-LIST 
            if ortho_set:
                U = self.orthogonalize(U, ortho_set)
            # ... UPDATE SOLUTION 
            U_new = self.singleUpdate(U, N, H, dum)
            # ... ROOT-MEAN SQUARED DEVIATION W.R.T. PREVIOUS STEP 
            acc = acc_fun(xi, U, U_new)
            # ... ADVANCE UPDATE TO NEXT ITERATION STEP 
            U = U_new
            # ... RE-EVALUATE THE INTEGRALS FOR THE CURRENT SOLUTION 
            N = self.functional_N(U_new)
            H = self.functional_H(U_new)
            # ... KEEP INTERMEDIATE RESULTS
            if it%nskip==0:
                self._update_results(it, U, N, H, H/N, acc)
            it+=1

        # -- KEEP FINAL SOLUTION 
        # ... ORTHOGONALIZE WRT NOT-LIST 
        if ortho_set:
            U = self.orthogonalize(U, ortho_set)
        self._update_results(it, U, N, H, H/N, acc)

        # -- BASIC STATUS MESSAGE
        if it&lt;maxiter:
            msg = f&#39;Iteration terminated successfully (num_iter = {it}).&#39;
        else:
            if it&gt;=maxiter:
                msg = &#39;Maximum number of iterations reached.&#39;
            if np.isnan(np.any(U)) or np.isnan(acc):
                msg = &#39;NaN result encountered.&#39;

        if self.verbose:
            print(f&#34;# {msg}&#34;)
            print(f&#34;# Functional 1: N = {N}&#34;)
            print(f&#34;# Functional 2: H = {H}&#34;)
            print(f&#34;# Eigenvalue: K = {H/N}&#34;)
            print(f&#34;# Local error: acc = {acc}&#34;)

        return self.U, self.acc, it&lt;maxiter, msg

    def orthogonalize(self, U, ortho_set):
        &#39;&#39;&#39;Otrhogonalization procedure.

        Implements a straight forward projection construction that turns the
        solution U into a solution U_ortho, which is orthogonal to any of the
        functions in the set `ortho_set`.

        Parameters
        ----------
        U : array_like
            Current solution.
        ortho_set : array_like
            Orthogonal set of previously found solutions.

        Returns
        -------
        U_ortho : array_like
            New solution which is orthogonal to any previously found solution.
        &#39;&#39;&#39;
        xi = self.xi
        # -- PROJECTION CONSTRUCTION 
        for V in ortho_set:
            # ... PROJECT OUT COMPONENT V 
            U -= V*np.sum(np.conj(V)*U)/np.sum(np.abs(V)**2)
        return U

    def functional_H(self, U):
        &#34;&#34;&#34;Functional number 2.

        Parameters
        ----------
        U : array_like
            Current solution.

        Raises
        ------
        NotImplementedError
            Must be overwritten by subclass.
        &#34;&#34;&#34;
        raise NotImplementedError

    def functional_N(self, U):
        &#34;&#34;&#34;Functional number 1.

        Parameters
        ----------
        U : array_like
            Current solution.

        Raises
        ------
        NotImplementedError
            Must be overwritten by subclass.
        &#34;&#34;&#34;
        raise NotImplementedError

    def singleUpdate(self, U, N, H, dum):
        &#34;&#34;&#34;Single update of the solution.

        Parameters
        ----------
        U : array_like
            Current solution.
        N : float
            Current value of functional 1.
        H : float
            Current value of functional 2.
        dum : float
            Eigenvalue (in case of SRM) or value of the normalization
            constraint (in case of NSOM).

        Raises
        ------
        NotImplementedError
            Must be overwritten by subclass.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __str__(self):
        &#34;&#34;&#34;str: String representation of the current solution.&#34;&#34;&#34;
        myStr = f&#34;Iter {self.num_iter:06d}: H = {self.H:7.6F}, N = {self.N:7.6F}, K = {self.kap:7.6F}, acc = {self.acc:4.3E}&#34;
        return myStr</code></pre>
</details>
<div class="desc"><p>Base class for the implemented iteration methods.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Discretized coordinate xi.</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence is assumed if relative error falls below this value
(defaulf: tol=1e-12).</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of iterations to perform (default: maxiter=10000).</dd>
<dt><strong><code>nskip</code></strong> :&ensp;<code>float</code></dt>
<dd>Number of iterations to skip in between storing intermediate results
(default: 1).</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True to print details during iteration (default: False).</dd>
<dt><strong><code>iter_list</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Sequence of iteration steps at which intermediate results where stored
(separated by nskip steps).</dd>
<dt><strong><code>U_list</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of intermediate solutions U.</dd>
<dt><strong><code>acc_list</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of intermediate accuracies (see class method _accuracy() below).</dd>
<dt><strong><code>N_list</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of intermediate values of the integral N[U].</dd>
<dt><strong><code>H_list</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of intermediate values of the integral H[U].</dd>
<dt><strong><code>K_list</code></strong> :&ensp;<code>array_like</code></dt>
<dd>List of intermediate values of the eigenvalue estimate K=H[U]/N[U].</dd>
</dl>
<p>Initialization of the iteration base class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Discretized coordinate xi.</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Iteration is stopped if the accuracy falls below this tolerance
threshold (default: 1e-12).</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of allowed iterations (default: 10000).</dd>
<dt><strong><code>nskip</code></strong> :&ensp;<code>1</code>, optional</dt>
<dd>Number of iterations to skip in between storing intermediate results (default: 1)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True to print details during iteration (default: False)</dd>
</dl></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="SWtools_base.NSOM" href="#SWtools_base.NSOM">NSOM</a></li>
<li><a title="SWtools_base.SRM" href="#SWtools_base.SRM">SRM</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="SWtools_base.IterBase.H"><code class="name">prop <span class="ident">H</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def H(self):
    &#39;&#39;&#39;float: Value of functional 2.&#39;&#39;&#39;
    return self.H_list[-1]</code></pre>
</details>
<div class="desc"><p>float: Value of functional 2.</p></div>
</dd>
<dt id="SWtools_base.IterBase.N"><code class="name">prop <span class="ident">N</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def N(self):
    &#39;&#39;&#39;float: Value of functional 1.&#39;&#39;&#39;
    return self.N_list[-1]</code></pre>
</details>
<div class="desc"><p>float: Value of functional 1.</p></div>
</dd>
<dt id="SWtools_base.IterBase.U"><code class="name">prop <span class="ident">U</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def U(self):
    &#39;&#39;&#39;float: Final solution U.&#39;&#39;&#39;
    return self.U_list[-1]</code></pre>
</details>
<div class="desc"><p>float: Final solution U.</p></div>
</dd>
<dt id="SWtools_base.IterBase.acc"><code class="name">prop <span class="ident">acc</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def acc(self):
    &#39;&#39;&#39;float: Terminal accuracy.&#39;&#39;&#39;
    return self.acc_list[-1]</code></pre>
</details>
<div class="desc"><p>float: Terminal accuracy.</p></div>
</dd>
<dt id="SWtools_base.IterBase.kap"><code class="name">prop <span class="ident">kap</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kap(self):
    &#39;&#39;&#39;float: Value of the eigenvalue.&#39;&#39;&#39;
    return self.K_list[-1]</code></pre>
</details>
<div class="desc"><p>float: Value of the eigenvalue.</p></div>
</dd>
<dt id="SWtools_base.IterBase.num_iter"><code class="name">prop <span class="ident">num_iter</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_iter(self):
    &#39;&#39;&#39;int: Number of iterations performed.&#39;&#39;&#39;
    return self.iter_list[-1]</code></pre>
</details>
<div class="desc"><p>int: Number of iterations performed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="SWtools_base.IterBase.functional_H"><code class="name flex">
<span>def <span class="ident">functional_H</span></span>(<span>self, U)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_H(self, U):
    &#34;&#34;&#34;Functional number 2.

    Parameters
    ----------
    U : array_like
        Current solution.

    Raises
    ------
    NotImplementedError
        Must be overwritten by subclass.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Functional number 2.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Must be overwritten by subclass.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.IterBase.functional_N"><code class="name flex">
<span>def <span class="ident">functional_N</span></span>(<span>self, U)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_N(self, U):
    &#34;&#34;&#34;Functional number 1.

    Parameters
    ----------
    U : array_like
        Current solution.

    Raises
    ------
    NotImplementedError
        Must be overwritten by subclass.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Functional number 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Must be overwritten by subclass.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.IterBase.orthogonalize"><code class="name flex">
<span>def <span class="ident">orthogonalize</span></span>(<span>self, U, ortho_set)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orthogonalize(self, U, ortho_set):
    &#39;&#39;&#39;Otrhogonalization procedure.

    Implements a straight forward projection construction that turns the
    solution U into a solution U_ortho, which is orthogonal to any of the
    functions in the set `ortho_set`.

    Parameters
    ----------
    U : array_like
        Current solution.
    ortho_set : array_like
        Orthogonal set of previously found solutions.

    Returns
    -------
    U_ortho : array_like
        New solution which is orthogonal to any previously found solution.
    &#39;&#39;&#39;
    xi = self.xi
    # -- PROJECTION CONSTRUCTION 
    for V in ortho_set:
        # ... PROJECT OUT COMPONENT V 
        U -= V*np.sum(np.conj(V)*U)/np.sum(np.abs(V)**2)
    return U</code></pre>
</details>
<div class="desc"><p>Otrhogonalization procedure.</p>
<p>Implements a straight forward projection construction that turns the
solution U into a solution U_ortho, which is orthogonal to any of the
functions in the set <code>ortho_set</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
<dt><strong><code>ortho_set</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Orthogonal set of previously found solutions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>U_ortho</code></strong> :&ensp;<code>array_like</code></dt>
<dd>New solution which is orthogonal to any previously found solution.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.IterBase.singleUpdate"><code class="name flex">
<span>def <span class="ident">singleUpdate</span></span>(<span>self, U, N, H, dum)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleUpdate(self, U, N, H, dum):
    &#34;&#34;&#34;Single update of the solution.

    Parameters
    ----------
    U : array_like
        Current solution.
    N : float
        Current value of functional 1.
    H : float
        Current value of functional 2.
    dum : float
        Eigenvalue (in case of SRM) or value of the normalization
        constraint (in case of NSOM).

    Raises
    ------
    NotImplementedError
        Must be overwritten by subclass.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Single update of the solution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>float</code></dt>
<dd>Current value of functional 1.</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>Current value of functional 2.</dd>
<dt><strong><code>dum</code></strong> :&ensp;<code>float</code></dt>
<dd>Eigenvalue (in case of SRM) or value of the normalization
constraint (in case of NSOM).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Must be overwritten by subclass.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.IterBase.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, U, dum, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, U, dum, **kwargs):
    &#39;&#39;&#39;Performs iteration procedure.

    Parameters
    ----------
    U : array_like
        Initial condition.
    dum : float
        Eigenvalue (in case of SRM) or value of the normalization
        constraint (in case of NSOM).
    ortho_set : array_like, keyword argument
        List of previously found orthogonal solutions.
    acc_fun : function, keyword argument
        Custom accuracy function with call signature `acc_fun(xi, Up, Uc)`,
        where the arguments are the coordinate xi (`xi`), the solution at the
        previous iteration step (`Up`), and the solution at the current
        iteration step (`Uc`).

    Returns
    -------
    U : array_like
        Final solutions.
    acc : float
        Terminal accuracy.
    succ : bool
        Boolean flag indicating if teh iteration procedure exited
        successfully.
    msg : str
        Cause of the termination.
    &#39;&#39;&#39;
    # -- USEFUL FUNCTIONS AND ABBREVIATIONS
    # ... STRIP SELF KEYWORD
    xi, tol, maxiter, nskip = self.xi, self.tol, self.maxiter, self.nskip
    # ... LOCAL FUNCTIONS
    acc_fun_def = lambda xi, U, Un: np.sqrt(np.sum(np.abs(Un - U)**2)/np.sum(np.abs(U)**2))
    # -- LOGIC TO MAP OUT KEYWORD ARGUMENTS
    ortho_set = kwargs.get(&#34;ortho_set&#34;, [])
    acc_fun = kwargs.get(&#34;acc_fun&#34;, acc_fun_def)
    # -- CLEAN UP
    self._clean_up()

    # -- PREPARE/EVALUATE TRIAL SOLUTION
    N = self.functional_N(U)
    H = self.functional_H(U)
    # -- INITIALIZE ITERATION SCHEME
    it = 1
    acc = np.inf
    # -- KEEP INITIAL RESULTS
    self._update_results(0, U, N, H, H/N, acc)
    # -- ITERATION PROCEDURE
    while acc &gt; tol and it &lt; maxiter:
        # ... ORTHOGONALIZE WRT NOT-LIST 
        if ortho_set:
            U = self.orthogonalize(U, ortho_set)
        # ... UPDATE SOLUTION 
        U_new = self.singleUpdate(U, N, H, dum)
        # ... ROOT-MEAN SQUARED DEVIATION W.R.T. PREVIOUS STEP 
        acc = acc_fun(xi, U, U_new)
        # ... ADVANCE UPDATE TO NEXT ITERATION STEP 
        U = U_new
        # ... RE-EVALUATE THE INTEGRALS FOR THE CURRENT SOLUTION 
        N = self.functional_N(U_new)
        H = self.functional_H(U_new)
        # ... KEEP INTERMEDIATE RESULTS
        if it%nskip==0:
            self._update_results(it, U, N, H, H/N, acc)
        it+=1

    # -- KEEP FINAL SOLUTION 
    # ... ORTHOGONALIZE WRT NOT-LIST 
    if ortho_set:
        U = self.orthogonalize(U, ortho_set)
    self._update_results(it, U, N, H, H/N, acc)

    # -- BASIC STATUS MESSAGE
    if it&lt;maxiter:
        msg = f&#39;Iteration terminated successfully (num_iter = {it}).&#39;
    else:
        if it&gt;=maxiter:
            msg = &#39;Maximum number of iterations reached.&#39;
        if np.isnan(np.any(U)) or np.isnan(acc):
            msg = &#39;NaN result encountered.&#39;

    if self.verbose:
        print(f&#34;# {msg}&#34;)
        print(f&#34;# Functional 1: N = {N}&#34;)
        print(f&#34;# Functional 2: H = {H}&#34;)
        print(f&#34;# Eigenvalue: K = {H/N}&#34;)
        print(f&#34;# Local error: acc = {acc}&#34;)

    return self.U, self.acc, it&lt;maxiter, msg</code></pre>
</details>
<div class="desc"><p>Performs iteration procedure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Initial condition.</dd>
<dt><strong><code>dum</code></strong> :&ensp;<code>float</code></dt>
<dd>Eigenvalue (in case of SRM) or value of the normalization
constraint (in case of NSOM).</dd>
<dt><strong><code>ortho_set</code></strong> :&ensp;<code>array_like, keyword argument</code></dt>
<dd>List of previously found orthogonal solutions.</dd>
<dt><strong><code>acc_fun</code></strong> :&ensp;<code>function, keyword argument</code></dt>
<dd>Custom accuracy function with call signature <code>acc_fun(xi, Up, Uc)</code>,
where the arguments are the coordinate xi (<code>xi</code>), the solution at the
previous iteration step (<code>Up</code>), and the solution at the current
iteration step (<code>Uc</code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Final solutions.</dd>
<dt><strong><code>acc</code></strong> :&ensp;<code>float</code></dt>
<dd>Terminal accuracy.</dd>
<dt><strong><code>succ</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean flag indicating if teh iteration procedure exited
successfully.</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>str</code></dt>
<dd>Cause of the termination.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="SWtools_base.NSOM"><code class="flex name class">
<span>class <span class="ident">NSOM</span></span>
<span>(</span><span>xi, cL, F, ORP=1.0, tol=1e-12, maxiter=10000, nskip=1, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NSOM(IterBase):
    &#34;&#34;&#34;Nonlinear Successive Overrelaxation Method (NSOM).

    Note
    ----
    This implementation addresses the case of a one-dimensional (d=1)
    transverse coordinate xi.
    &#34;&#34;&#34;
    def __init__(self, xi, cL, F, ORP=1.0, tol=1e-12, maxiter=10000, nskip=1, verbose=False):
        &#34;&#34;&#34;Initialization of the iteration base class.

        Parameters
        ----------
        xi : array_like
            Discretized coordinate xi.
        cL : array_like
            Coefficients c_L = (c_1, c_2, c_3, c_4) defining the linera operator L.
        F : function
            Nonlinear functional with call signature `F(I, xi)`, where the
            arguments are the squared magnitute of U (`I`), and the transverse
            coordinate xi (`xi`).
        ORP : float, optional
            Overrelaxation parameter (default: 1). Numerical value needs to
            satisfy ORP&lt;2.  If ORP&lt;1, the method works by underrelaxing.
        tol : float, optional
            Iteration is stopped if the accuracy falls below this tolerance
            threshold (default: 1e-12).
        maxiter : int, optional
            Maximum number of allowed iterations (default: 10000).
        nskip : 1, optional
            Number of iterations to skip in between storing intermediate results (default: 1)
        verbose : bool
            Set to True to print details during iteration (default: False)
        &#34;&#34;&#34;
        IterBase.__init__(self, xi, tol=tol, maxiter=maxiter, nskip=nskip, verbose=verbose)
        self.dxi = xi[1]-xi[0]
        self.F = F
        self.coeffs = self._set_coeffs(cL)
        self.ORP = ORP

    def _set_coeffs(self,coeffs):
        dxi = self.dxi
        dxi2 = dxi**2
        c1, c2, c3, c4 = coeffs
        return [ 1j*dxi*c1/12 + c2/12 + 0.5j*c3/dxi + c4/dxi2,\
                -2j*dxi*c1/3 -c2*4/3 - 1j*c3/dxi - c4*4/dxi2,\
                -c2*5/2 - c4*6/dxi2,\
                 2j*dxi*c1/3 -c2*4/3 + 1j*c3/dxi - c4*4/dxi2,\
                -1j*dxi*c1/12 + c2/12 - 0.5j*c3/dxi + c4/dxi2]

    def functional_N(self, U):
        &#34;&#34;&#34;Functional number 1.

        Parameters
        ----------
        U : array_like
            Current solution.

        Returns
        -------
        N : float
            Value of the functional N at the current iteration step.
        &#34;&#34;&#34;
        return np.trapz(np.abs(U)**2, x=self.xi)

    def functional_H(self, U):
        &#34;&#34;&#34;Functional number 2.

        Implements functional H by employing a discretized linear operator L in
        which all derivatives are replaced by their corresponding five-point
        finite-difference approximations.

        Parameters
        ----------
        U : array_like
            Current solution.

        Returns
        -------
        H : float
            Value of the functional H at the current iteration step.
        &#34;&#34;&#34;
        xi, dxi, F = self.xi, self.dxi, self.F
        am2, am1, a0, ap1, ap2 = self.coeffs
        HL = np.trapz( (am2*U[:-4] + am1*U[1:-3] - a0*U[2:-2] + ap1*U[3:-1] + ap2*U[4:] )*np.conj(U[2:-2]) , dx=1)/dxi
        HN = np.trapz(F(np.abs(U)**2, xi)*np.abs(U)**2, x=xi)
        return np.real(HL + HN)

    def singleUpdate(self, U, N, H, N0):
        &#34;&#34;&#34;Single iteration step of the NSOM.

        Implements a single step of a nonlinear successive overrelaxation
        method [LM2019] for a generalized nonlinear Schrödinger equation. The
        procedure uses a Gauss-Seidel method with overrelaxation to iteratively
        updata a user-provided initial condition in place [NR2007,LL2017].

        References
        ----------
        [NR2007] W. Press, S. Teukolsky, W. Vetterling, B. Flannery, Numerical
        Recipes: The Art of Scientific Computing, Cambridge University Press
        (2007).

        [LL2017] H. P. Langtangen, S. Linge, Finite-Difference Computing with PDEs,
        Springer (2017).

        [LM2019] H. P. Langtangen, K.-A. Mardal, Introduction to Numerical Methods
        for Variational Problems, Springer (2019).

        Parameters
        ----------
        U : array_like
            Current solution.
        N : float
            Current value of functional 1.
        H : float
            Current value of functional 2.
        dum : float
            Eigenvalue (in case of SRM) or value of the normalization
            constraint (in case of NSOM).

        Returns
        -------
        U : array_like
            Updated solution.
        &#34;&#34;&#34;
        # -- STRIP SELF KEYWORD
        xi, dxi, F, ORP = self.xi, self.dxi, self.F, self.ORP
        am2, am1, a0, ap1, ap2 = self.coeffs
        # -- USEFUL FUNCTIONS AND ABBREVIATIONS 
        _norm = lambda U, N0: U*np.sqrt(N0/np.trapz(np.abs(U)**2,x=xi))

        # -- GAUSS-SEIDEL RELAXATION PROCEDURE
        for i in range(2,xi.size-2):
            # ... KEEP OLD VALUE FOR REFERENCE
            Ui = U[i]
            xii = xi[i]
            # ... AVERAGE VALUE ACCROSS LOCAL NEIGHBORHOOD
            Ui_nbs_wgt = am2*U[i-2] + am1*U[i-1] + ap1*U[i+1] + ap2*U[i+2]
            # ... LOCAL POTENTIAL
            Vi = -F(np.abs(Ui)**2, xii)
            # ... UPDATE PIVOT
            num = Ui_nbs_wgt
            den =  a0 + (H/N + Vi)*dxi**2
            Ui_new = num/den
            # ... UPDATE SOLUTION USING OVERRELAXATION 
            U[i] += ORP*(Ui_new-Ui)

        # -- SCALE SOLUTION TO DESIRED ENERGY 
        U = _norm(U,N0)

        return U

    def show(self, f_name=&#39;none&#39;):
        &#34;&#34;&#34;Prepare simple plot showing the results.

        Uses Pythons matplotlibe to prepare a two-panel figure that might be
        captioned as follows:

        Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
        panel: Solution U.  Shown are the real part (Re[U]), imaginary part
        (Im[U]), and modulus (|U|) of the solution.  Right panel: Variation of the
        accuracy upon iteration.

        Parameters
        ----------
        f_name : str, optional
            Figure name. If no name is set, the figure is displayed directly.
        &#34;&#34;&#34;
        xi, U, it, acc = self.xi, self.U, self.iter_list, self.acc_list
        helper_show_d1(xi, U, it, acc, f_name=f_name)</code></pre>
</details>
<div class="desc"><p>Nonlinear Successive Overrelaxation Method (NSOM).</p>
<h2 id="note">Note</h2>
<p>This implementation addresses the case of a one-dimensional (d=1)
transverse coordinate xi.</p>
<p>Initialization of the iteration base class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Discretized coordinate xi.</dd>
<dt><strong><code>cL</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Coefficients c_L = (c_1, c_2, c_3, c_4) defining the linera operator L.</dd>
<dt><strong><code>F</code></strong> :&ensp;<code>function</code></dt>
<dd>Nonlinear functional with call signature <code>F(I, xi)</code>, where the
arguments are the squared magnitute of U (<code>I</code>), and the transverse
coordinate xi (<code>xi</code>).</dd>
<dt><strong><code>ORP</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Overrelaxation parameter (default: 1). Numerical value needs to
satisfy ORP&lt;2.
If ORP&lt;1, the method works by underrelaxing.</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Iteration is stopped if the accuracy falls below this tolerance
threshold (default: 1e-12).</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of allowed iterations (default: 10000).</dd>
<dt><strong><code>nskip</code></strong> :&ensp;<code>1</code>, optional</dt>
<dd>Number of iterations to skip in between storing intermediate results (default: 1)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True to print details during iteration (default: False)</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="SWtools_base.IterBase" href="#SWtools_base.IterBase">IterBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="SWtools_base.NSOM.functional_H"><code class="name flex">
<span>def <span class="ident">functional_H</span></span>(<span>self, U)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_H(self, U):
    &#34;&#34;&#34;Functional number 2.

    Implements functional H by employing a discretized linear operator L in
    which all derivatives are replaced by their corresponding five-point
    finite-difference approximations.

    Parameters
    ----------
    U : array_like
        Current solution.

    Returns
    -------
    H : float
        Value of the functional H at the current iteration step.
    &#34;&#34;&#34;
    xi, dxi, F = self.xi, self.dxi, self.F
    am2, am1, a0, ap1, ap2 = self.coeffs
    HL = np.trapz( (am2*U[:-4] + am1*U[1:-3] - a0*U[2:-2] + ap1*U[3:-1] + ap2*U[4:] )*np.conj(U[2:-2]) , dx=1)/dxi
    HN = np.trapz(F(np.abs(U)**2, xi)*np.abs(U)**2, x=xi)
    return np.real(HL + HN)</code></pre>
</details>
<div class="desc"><p>Functional number 2.</p>
<p>Implements functional H by employing a discretized linear operator L in
which all derivatives are replaced by their corresponding five-point
finite-difference approximations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the functional H at the current iteration step.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.NSOM.functional_N"><code class="name flex">
<span>def <span class="ident">functional_N</span></span>(<span>self, U)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_N(self, U):
    &#34;&#34;&#34;Functional number 1.

    Parameters
    ----------
    U : array_like
        Current solution.

    Returns
    -------
    N : float
        Value of the functional N at the current iteration step.
    &#34;&#34;&#34;
    return np.trapz(np.abs(U)**2, x=self.xi)</code></pre>
</details>
<div class="desc"><p>Functional number 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the functional N at the current iteration step.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.NSOM.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, f_name='none')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, f_name=&#39;none&#39;):
    &#34;&#34;&#34;Prepare simple plot showing the results.

    Uses Pythons matplotlibe to prepare a two-panel figure that might be
    captioned as follows:

    Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
    panel: Solution U.  Shown are the real part (Re[U]), imaginary part
    (Im[U]), and modulus (|U|) of the solution.  Right panel: Variation of the
    accuracy upon iteration.

    Parameters
    ----------
    f_name : str, optional
        Figure name. If no name is set, the figure is displayed directly.
    &#34;&#34;&#34;
    xi, U, it, acc = self.xi, self.U, self.iter_list, self.acc_list
    helper_show_d1(xi, U, it, acc, f_name=f_name)</code></pre>
</details>
<div class="desc"><p>Prepare simple plot showing the results.</p>
<p>Uses Pythons matplotlibe to prepare a two-panel figure that might be
captioned as follows:</p>
<p>Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
panel: Solution U.
Shown are the real part (Re[U]), imaginary part
(Im[U]), and modulus (|U|) of the solution.
Right panel: Variation of the
accuracy upon iteration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Figure name. If no name is set, the figure is displayed directly.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.NSOM.singleUpdate"><code class="name flex">
<span>def <span class="ident">singleUpdate</span></span>(<span>self, U, N, H, N0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleUpdate(self, U, N, H, N0):
    &#34;&#34;&#34;Single iteration step of the NSOM.

    Implements a single step of a nonlinear successive overrelaxation
    method [LM2019] for a generalized nonlinear Schrödinger equation. The
    procedure uses a Gauss-Seidel method with overrelaxation to iteratively
    updata a user-provided initial condition in place [NR2007,LL2017].

    References
    ----------
    [NR2007] W. Press, S. Teukolsky, W. Vetterling, B. Flannery, Numerical
    Recipes: The Art of Scientific Computing, Cambridge University Press
    (2007).

    [LL2017] H. P. Langtangen, S. Linge, Finite-Difference Computing with PDEs,
    Springer (2017).

    [LM2019] H. P. Langtangen, K.-A. Mardal, Introduction to Numerical Methods
    for Variational Problems, Springer (2019).

    Parameters
    ----------
    U : array_like
        Current solution.
    N : float
        Current value of functional 1.
    H : float
        Current value of functional 2.
    dum : float
        Eigenvalue (in case of SRM) or value of the normalization
        constraint (in case of NSOM).

    Returns
    -------
    U : array_like
        Updated solution.
    &#34;&#34;&#34;
    # -- STRIP SELF KEYWORD
    xi, dxi, F, ORP = self.xi, self.dxi, self.F, self.ORP
    am2, am1, a0, ap1, ap2 = self.coeffs
    # -- USEFUL FUNCTIONS AND ABBREVIATIONS 
    _norm = lambda U, N0: U*np.sqrt(N0/np.trapz(np.abs(U)**2,x=xi))

    # -- GAUSS-SEIDEL RELAXATION PROCEDURE
    for i in range(2,xi.size-2):
        # ... KEEP OLD VALUE FOR REFERENCE
        Ui = U[i]
        xii = xi[i]
        # ... AVERAGE VALUE ACCROSS LOCAL NEIGHBORHOOD
        Ui_nbs_wgt = am2*U[i-2] + am1*U[i-1] + ap1*U[i+1] + ap2*U[i+2]
        # ... LOCAL POTENTIAL
        Vi = -F(np.abs(Ui)**2, xii)
        # ... UPDATE PIVOT
        num = Ui_nbs_wgt
        den =  a0 + (H/N + Vi)*dxi**2
        Ui_new = num/den
        # ... UPDATE SOLUTION USING OVERRELAXATION 
        U[i] += ORP*(Ui_new-Ui)

    # -- SCALE SOLUTION TO DESIRED ENERGY 
    U = _norm(U,N0)

    return U</code></pre>
</details>
<div class="desc"><p>Single iteration step of the NSOM.</p>
<p>Implements a single step of a nonlinear successive overrelaxation
method [LM2019] for a generalized nonlinear Schrödinger equation. The
procedure uses a Gauss-Seidel method with overrelaxation to iteratively
updata a user-provided initial condition in place [NR2007,LL2017].</p>
<h2 id="references">References</h2>
<p>[NR2007] W. Press, S. Teukolsky, W. Vetterling, B. Flannery, Numerical
Recipes: The Art of Scientific Computing, Cambridge University Press
(2007).</p>
<p>[LL2017] H. P. Langtangen, S. Linge, Finite-Difference Computing with PDEs,
Springer (2017).</p>
<p>[LM2019] H. P. Langtangen, K.-A. Mardal, Introduction to Numerical Methods
for Variational Problems, Springer (2019).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>float</code></dt>
<dd>Current value of functional 1.</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>Current value of functional 2.</dd>
<dt><strong><code>dum</code></strong> :&ensp;<code>float</code></dt>
<dd>Eigenvalue (in case of SRM) or value of the normalization
constraint (in case of NSOM).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Updated solution.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="SWtools_base.IterBase" href="#SWtools_base.IterBase">IterBase</a></b></code>:
<ul class="hlist">
<li><code><a title="SWtools_base.IterBase.H" href="#SWtools_base.IterBase.H">H</a></code></li>
<li><code><a title="SWtools_base.IterBase.N" href="#SWtools_base.IterBase.N">N</a></code></li>
<li><code><a title="SWtools_base.IterBase.U" href="#SWtools_base.IterBase.U">U</a></code></li>
<li><code><a title="SWtools_base.IterBase.acc" href="#SWtools_base.IterBase.acc">acc</a></code></li>
<li><code><a title="SWtools_base.IterBase.kap" href="#SWtools_base.IterBase.kap">kap</a></code></li>
<li><code><a title="SWtools_base.IterBase.num_iter" href="#SWtools_base.IterBase.num_iter">num_iter</a></code></li>
<li><code><a title="SWtools_base.IterBase.orthogonalize" href="#SWtools_base.IterBase.orthogonalize">orthogonalize</a></code></li>
<li><code><a title="SWtools_base.IterBase.solve" href="#SWtools_base.IterBase.solve">solve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="SWtools_base.SRM"><code class="flex name class">
<span>class <span class="ident">SRM</span></span>
<span>(</span><span>xi, cL, F, tol=1e-12, maxiter=10000, nskip=1, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SRM(IterBase):
    &#34;&#34;&#34;Spectral renormalization method (SRM).

    Note
    ----
    This implementation addresses the case of a one-dimensional (d=1)
    transverse coordinate xi.
    &#34;&#34;&#34;
    def __init__(self, xi, cL, F, tol=1e-12, maxiter=10000, nskip=1, verbose=False):
        &#34;&#34;&#34;Initialization of the iteration base class.

        Parameters
        ----------
        xi : array_like
            Discretized coordinate xi.
        cL : array_like
            Coefficients c_L = (c_1, c_2, c_3, c_4) defining the linera operator L.
        F : function
            Nonlinear functional with call signature `F(I, xi)`, where the
            arguments are the squared magnitute of U (`I`), and the transverse
            coordinate xi (`xi`).
        tol : float, optional
            Iteration is stopped if the accuracy falls below this tolerance
            threshold (default: 1e-12).
        maxiter : int, optional
            Maximum number of allowed iterations (default: 10000).
        nskip : 1, optional
            Number of iterations to skip in between storing intermediate results (default: 1)
        verbose : bool
            Set to True to print details during iteration (default: False)
        &#34;&#34;&#34;
        IterBase.__init__(self, xi, tol=tol, maxiter=maxiter, nskip=nskip, verbose=verbose)
        self.F = F
        self.Lw = self._set_Lk(xi, cL)
        self.gam = 1.5

    def _set_Lk(self, xi, coeffs):
        c1, c2, c3, c4 = coeffs
        k = FTFREQ(xi.size, d=xi[1]-xi[0])*2*np.pi
        return c1*k + c2*k**2 + c3*k**3 + c4*k**4

    def functional_N(self, U):
        &#34;&#34;&#34;Functional number 1.

        Parameters
        ----------
        U : array_like
            Current solution.

        Returns
        -------
        N : float
            Value of the functional N at the current iteration step.
        &#34;&#34;&#34;
        return np.trapz(np.abs(U)**2, x=self.xi, axis=-1)

    def functional_H(self, U):
        &#34;&#34;&#34;Functional number 2.

        Implements functional H by employing spectral derivatives to handle the
        linear operator L.

        Parameters
        ----------
        U : array_like
            Current solution.

        Returns
        -------
        H : float
            Value of the functional H at the current iteration step.
        &#34;&#34;&#34;
        xi, Lw, F = self.xi, self.Lw, self.F
        return np.real(np.trapz( np.conj(U)*IFT(Lw*FT(U)) + F(np.abs(U)**2, xi)*np.abs(U)**2, x=xi, axis=-1))

    def singleUpdate(self, U, N, H, kap):
        &#34;&#34;&#34;Single iteration step of the SRM.

        Implements a single step of the d=1 SRM, thoroughly detailed in
        [A2003,M2004,A2005,F2008,A2009].

        References
        ----------
        [A2003] M. J. Ablowitz, Z. H. Musslimani, Discrete spatial solitons in
        a diffraction-managed nonlinear waveguide array: a unified approach,
        Physica D 184 (2003) 276–303,
        https://doi.org/10.1016/S0167-2789(03)00226-4.

        [M2004] Z. Musslimani, J. Yang, Self-trapping of light in a
        two-dimensional photonic lattice, J. Opt. Soc. Am.  B 21 (2004) 973,
        https://doi.org/10.1364/JOSAB.21.000973.

        [A2005] M. J. Ablowitz, Z. H. Musslimani, Spectral renormalization
        method for computing self-localized solutions to nonlinear systems,
        Opt. Lett. 30 (2005) 2140, https://doi.org/10.1364/OL.30.002140.

        [F2008] G. Fibich, Y. Sivan, M. I. Weinstein, Bound states of nonlinear
        Schrödinger equations with a periodic nonlinear microstructure, Physica
        D 217 (2006) 31, https://doi.org/10.1016/j.physd.2006.03.009.

        [A2009] M. Ablowitz, T. Horikis, Solitons and spectral renormalization
        methods in nonlinear optics, Eur. Phys. J.  Spec. Top. 173 (2009) 147,
        https://doi.org/10.1140/epjst/e2009-01072-0.

        Parameters
        ----------
        U : array_like
            Current solution.
        N : float
            Current value of functional 1.
        H : float
            Current value of functional 2.
        kap : float
            Eigenvalue of the sought-for solution.

        Returns
        -------
        U : array_like
            Updated solution.
        &#34;&#34;&#34;
        # -- STRIP SELF KEYWORD
        xi, Lw, F, gam = self.xi, self.Lw, self.F, self.gam
        # -- USEFUL FUNCTIONS AND ABBREVIATIONS 
        _IP = lambda f,g: np.trapz(np.conj(f)*g, x=xi)

        # -- SRM UPDATE
        # (1) PROPOSE UPDATED SOLUTION
        U_tmp = IFT(FT(F(np.abs(U)**2,xi)*U)/(kap - Lw))
        # (2) RESCALE SOLUTION SO IT SATISFIES THE DESIRED INTEGRAL IDENTITY
        s_tmp = np.abs(_IP(U,U)/_IP(U,U_tmp))
        U_tmp *= s_tmp**gam

        return U_tmp

    def show(self, f_name=&#39;none&#39;):
        &#34;&#34;&#34;Prepare simple plot showing the results.

        Uses Pythons matplotlibe to prepare a two-panel figure that might be
        captioned as follows:

        Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
        panel: Solution U.  Shown are the real part (Re[U]), imaginary part
        (Im[U]), and modulus (|U|) of the solution.  Right panel: Variation of the
        accuracy upon iteration.

        Parameters
        ----------
        f_name : str, optional
            Figure name. If no name is set, the figure is displayed directly.
        &#34;&#34;&#34;
        xi, U, it, acc = self.xi, self.U, self.iter_list, self.acc_list
        helper_show_d1(xi, U, it, acc, f_name=f_name)</code></pre>
</details>
<div class="desc"><p>Spectral renormalization method (SRM).</p>
<h2 id="note">Note</h2>
<p>This implementation addresses the case of a one-dimensional (d=1)
transverse coordinate xi.</p>
<p>Initialization of the iteration base class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Discretized coordinate xi.</dd>
<dt><strong><code>cL</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Coefficients c_L = (c_1, c_2, c_3, c_4) defining the linera operator L.</dd>
<dt><strong><code>F</code></strong> :&ensp;<code>function</code></dt>
<dd>Nonlinear functional with call signature <code>F(I, xi)</code>, where the
arguments are the squared magnitute of U (<code>I</code>), and the transverse
coordinate xi (<code>xi</code>).</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Iteration is stopped if the accuracy falls below this tolerance
threshold (default: 1e-12).</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of allowed iterations (default: 10000).</dd>
<dt><strong><code>nskip</code></strong> :&ensp;<code>1</code>, optional</dt>
<dd>Number of iterations to skip in between storing intermediate results (default: 1)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True to print details during iteration (default: False)</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="SWtools_base.IterBase" href="#SWtools_base.IterBase">IterBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="SWtools_base.SRM.functional_H"><code class="name flex">
<span>def <span class="ident">functional_H</span></span>(<span>self, U)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_H(self, U):
    &#34;&#34;&#34;Functional number 2.

    Implements functional H by employing spectral derivatives to handle the
    linear operator L.

    Parameters
    ----------
    U : array_like
        Current solution.

    Returns
    -------
    H : float
        Value of the functional H at the current iteration step.
    &#34;&#34;&#34;
    xi, Lw, F = self.xi, self.Lw, self.F
    return np.real(np.trapz( np.conj(U)*IFT(Lw*FT(U)) + F(np.abs(U)**2, xi)*np.abs(U)**2, x=xi, axis=-1))</code></pre>
</details>
<div class="desc"><p>Functional number 2.</p>
<p>Implements functional H by employing spectral derivatives to handle the
linear operator L.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the functional H at the current iteration step.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.SRM.functional_N"><code class="name flex">
<span>def <span class="ident">functional_N</span></span>(<span>self, U)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_N(self, U):
    &#34;&#34;&#34;Functional number 1.

    Parameters
    ----------
    U : array_like
        Current solution.

    Returns
    -------
    N : float
        Value of the functional N at the current iteration step.
    &#34;&#34;&#34;
    return np.trapz(np.abs(U)**2, x=self.xi, axis=-1)</code></pre>
</details>
<div class="desc"><p>Functional number 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the functional N at the current iteration step.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.SRM.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, f_name='none')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, f_name=&#39;none&#39;):
    &#34;&#34;&#34;Prepare simple plot showing the results.

    Uses Pythons matplotlibe to prepare a two-panel figure that might be
    captioned as follows:

    Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
    panel: Solution U.  Shown are the real part (Re[U]), imaginary part
    (Im[U]), and modulus (|U|) of the solution.  Right panel: Variation of the
    accuracy upon iteration.

    Parameters
    ----------
    f_name : str, optional
        Figure name. If no name is set, the figure is displayed directly.
    &#34;&#34;&#34;
    xi, U, it, acc = self.xi, self.U, self.iter_list, self.acc_list
    helper_show_d1(xi, U, it, acc, f_name=f_name)</code></pre>
</details>
<div class="desc"><p>Prepare simple plot showing the results.</p>
<p>Uses Pythons matplotlibe to prepare a two-panel figure that might be
captioned as follows:</p>
<p>Nonlinear bound state of the considered nonlinear eigenvalue problem. Left
panel: Solution U.
Shown are the real part (Re[U]), imaginary part
(Im[U]), and modulus (|U|) of the solution.
Right panel: Variation of the
accuracy upon iteration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Figure name. If no name is set, the figure is displayed directly.</dd>
</dl></div>
</dd>
<dt id="SWtools_base.SRM.singleUpdate"><code class="name flex">
<span>def <span class="ident">singleUpdate</span></span>(<span>self, U, N, H, kap)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleUpdate(self, U, N, H, kap):
    &#34;&#34;&#34;Single iteration step of the SRM.

    Implements a single step of the d=1 SRM, thoroughly detailed in
    [A2003,M2004,A2005,F2008,A2009].

    References
    ----------
    [A2003] M. J. Ablowitz, Z. H. Musslimani, Discrete spatial solitons in
    a diffraction-managed nonlinear waveguide array: a unified approach,
    Physica D 184 (2003) 276–303,
    https://doi.org/10.1016/S0167-2789(03)00226-4.

    [M2004] Z. Musslimani, J. Yang, Self-trapping of light in a
    two-dimensional photonic lattice, J. Opt. Soc. Am.  B 21 (2004) 973,
    https://doi.org/10.1364/JOSAB.21.000973.

    [A2005] M. J. Ablowitz, Z. H. Musslimani, Spectral renormalization
    method for computing self-localized solutions to nonlinear systems,
    Opt. Lett. 30 (2005) 2140, https://doi.org/10.1364/OL.30.002140.

    [F2008] G. Fibich, Y. Sivan, M. I. Weinstein, Bound states of nonlinear
    Schrödinger equations with a periodic nonlinear microstructure, Physica
    D 217 (2006) 31, https://doi.org/10.1016/j.physd.2006.03.009.

    [A2009] M. Ablowitz, T. Horikis, Solitons and spectral renormalization
    methods in nonlinear optics, Eur. Phys. J.  Spec. Top. 173 (2009) 147,
    https://doi.org/10.1140/epjst/e2009-01072-0.

    Parameters
    ----------
    U : array_like
        Current solution.
    N : float
        Current value of functional 1.
    H : float
        Current value of functional 2.
    kap : float
        Eigenvalue of the sought-for solution.

    Returns
    -------
    U : array_like
        Updated solution.
    &#34;&#34;&#34;
    # -- STRIP SELF KEYWORD
    xi, Lw, F, gam = self.xi, self.Lw, self.F, self.gam
    # -- USEFUL FUNCTIONS AND ABBREVIATIONS 
    _IP = lambda f,g: np.trapz(np.conj(f)*g, x=xi)

    # -- SRM UPDATE
    # (1) PROPOSE UPDATED SOLUTION
    U_tmp = IFT(FT(F(np.abs(U)**2,xi)*U)/(kap - Lw))
    # (2) RESCALE SOLUTION SO IT SATISFIES THE DESIRED INTEGRAL IDENTITY
    s_tmp = np.abs(_IP(U,U)/_IP(U,U_tmp))
    U_tmp *= s_tmp**gam

    return U_tmp</code></pre>
</details>
<div class="desc"><p>Single iteration step of the SRM.</p>
<p>Implements a single step of the d=1 SRM, thoroughly detailed in
[A2003,M2004,A2005,F2008,A2009].</p>
<h2 id="references">References</h2>
<p>[A2003] M. J. Ablowitz, Z. H. Musslimani, Discrete spatial solitons in
a diffraction-managed nonlinear waveguide array: a unified approach,
Physica D 184 (2003) 276–303,
<a href="https://doi.org/10.1016/S0167-2789(03)00226-4.">https://doi.org/10.1016/S0167-2789(03)00226-4.</a></p>
<p>[M2004] Z. Musslimani, J. Yang, Self-trapping of light in a
two-dimensional photonic lattice, J. Opt. Soc. Am.
B 21 (2004) 973,
<a href="https://doi.org/10.1364/JOSAB.21.000973.">https://doi.org/10.1364/JOSAB.21.000973.</a></p>
<p>[A2005] M. J. Ablowitz, Z. H. Musslimani, Spectral renormalization
method for computing self-localized solutions to nonlinear systems,
Opt. Lett. 30 (2005) 2140, <a href="https://doi.org/10.1364/OL.30.002140.">https://doi.org/10.1364/OL.30.002140.</a></p>
<p>[F2008] G. Fibich, Y. Sivan, M. I. Weinstein, Bound states of nonlinear
Schrödinger equations with a periodic nonlinear microstructure, Physica
D 217 (2006) 31, <a href="https://doi.org/10.1016/j.physd.2006.03.009.">https://doi.org/10.1016/j.physd.2006.03.009.</a></p>
<p>[A2009] M. Ablowitz, T. Horikis, Solitons and spectral renormalization
methods in nonlinear optics, Eur. Phys. J.
Spec. Top. 173 (2009) 147,
<a href="https://doi.org/10.1140/epjst/e2009-01072-0.">https://doi.org/10.1140/epjst/e2009-01072-0.</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Current solution.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>float</code></dt>
<dd>Current value of functional 1.</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>Current value of functional 2.</dd>
<dt><strong><code>kap</code></strong> :&ensp;<code>float</code></dt>
<dd>Eigenvalue of the sought-for solution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>U</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Updated solution.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="SWtools_base.IterBase" href="#SWtools_base.IterBase">IterBase</a></b></code>:
<ul class="hlist">
<li><code><a title="SWtools_base.IterBase.H" href="#SWtools_base.IterBase.H">H</a></code></li>
<li><code><a title="SWtools_base.IterBase.N" href="#SWtools_base.IterBase.N">N</a></code></li>
<li><code><a title="SWtools_base.IterBase.U" href="#SWtools_base.IterBase.U">U</a></code></li>
<li><code><a title="SWtools_base.IterBase.acc" href="#SWtools_base.IterBase.acc">acc</a></code></li>
<li><code><a title="SWtools_base.IterBase.kap" href="#SWtools_base.IterBase.kap">kap</a></code></li>
<li><code><a title="SWtools_base.IterBase.num_iter" href="#SWtools_base.IterBase.num_iter">num_iter</a></code></li>
<li><code><a title="SWtools_base.IterBase.orthogonalize" href="#SWtools_base.IterBase.orthogonalize">orthogonalize</a></code></li>
<li><code><a title="SWtools_base.IterBase.solve" href="#SWtools_base.IterBase.solve">solve</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="SWtools_base.helper_show_d1" href="#SWtools_base.helper_show_d1">helper_show_d1</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SWtools_base.IterBase" href="#SWtools_base.IterBase">IterBase</a></code></h4>
<ul class="two-column">
<li><code><a title="SWtools_base.IterBase.H" href="#SWtools_base.IterBase.H">H</a></code></li>
<li><code><a title="SWtools_base.IterBase.N" href="#SWtools_base.IterBase.N">N</a></code></li>
<li><code><a title="SWtools_base.IterBase.U" href="#SWtools_base.IterBase.U">U</a></code></li>
<li><code><a title="SWtools_base.IterBase.acc" href="#SWtools_base.IterBase.acc">acc</a></code></li>
<li><code><a title="SWtools_base.IterBase.functional_H" href="#SWtools_base.IterBase.functional_H">functional_H</a></code></li>
<li><code><a title="SWtools_base.IterBase.functional_N" href="#SWtools_base.IterBase.functional_N">functional_N</a></code></li>
<li><code><a title="SWtools_base.IterBase.kap" href="#SWtools_base.IterBase.kap">kap</a></code></li>
<li><code><a title="SWtools_base.IterBase.num_iter" href="#SWtools_base.IterBase.num_iter">num_iter</a></code></li>
<li><code><a title="SWtools_base.IterBase.orthogonalize" href="#SWtools_base.IterBase.orthogonalize">orthogonalize</a></code></li>
<li><code><a title="SWtools_base.IterBase.singleUpdate" href="#SWtools_base.IterBase.singleUpdate">singleUpdate</a></code></li>
<li><code><a title="SWtools_base.IterBase.solve" href="#SWtools_base.IterBase.solve">solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="SWtools_base.NSOM" href="#SWtools_base.NSOM">NSOM</a></code></h4>
<ul class="">
<li><code><a title="SWtools_base.NSOM.functional_H" href="#SWtools_base.NSOM.functional_H">functional_H</a></code></li>
<li><code><a title="SWtools_base.NSOM.functional_N" href="#SWtools_base.NSOM.functional_N">functional_N</a></code></li>
<li><code><a title="SWtools_base.NSOM.show" href="#SWtools_base.NSOM.show">show</a></code></li>
<li><code><a title="SWtools_base.NSOM.singleUpdate" href="#SWtools_base.NSOM.singleUpdate">singleUpdate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="SWtools_base.SRM" href="#SWtools_base.SRM">SRM</a></code></h4>
<ul class="">
<li><code><a title="SWtools_base.SRM.functional_H" href="#SWtools_base.SRM.functional_H">functional_H</a></code></li>
<li><code><a title="SWtools_base.SRM.functional_N" href="#SWtools_base.SRM.functional_N">functional_N</a></code></li>
<li><code><a title="SWtools_base.SRM.show" href="#SWtools_base.SRM.show">show</a></code></li>
<li><code><a title="SWtools_base.SRM.singleUpdate" href="#SWtools_base.SRM.singleUpdate">singleUpdate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
